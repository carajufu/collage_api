<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<<<<<<< Updated upstream
<mapper namespace="kr.ac.collage_api.mapper.DitAccountMapper">
=======
<mapper namespace="kr.ac.collage_api.security.mapper.DitAccountMapper">
>>>>>>> Stashed changes
  	<!--
      블록: acntMap (계정 + 권한 + 헤더 표시 정보 바인딩)

      1) 코드 의도
         - ACNT(계정 정보) 한 건과 AUTHOR(권한 목록) 다건을
<<<<<<< Updated upstream
           AcntVO.authorList(List<AuthorVO>) 형태로 한 번에 적재
=======
           AcntVO.authorVOList(List<AuthorVO>) 형태로 한 번에 적재
>>>>>>> Stashed changes
         - 동시에 상단 헤더/메인 포털에서 쓸 표시 정보까지 미리 계산해서 올림
           · USER_NM          : 사용자 이름(학생/교수/관리자)
           · USER_STTUS_NM    : 학적/재직 상태 표시 문자열
           · USER_SUBJCT_NM   : 소속 학과명
           · USER_NO          : 학생 → 학번, 교수 → 교번

      2) 데이터 흐름
         - 입력 : findById SELECT 결과
                  (ACNT A
                   LEFT JOIN AUTHOR B
                   LEFT JOIN STDNT S
                   LEFT JOIN SUBJCT SJ_S
                   LEFT JOIN SKLSTF T
                   LEFT JOIN PROFSR PR
                   LEFT JOIN SUBJCT SJ_P)
         - 가공 :
           · A.* 컬럼 → AcntVO 기본 필드
             - ACNT_ID       → acntId
             - FILE_GROUP_NO → fileGroupNo
             - PASSWORD      → password
             - ACNT_TY       → acntTy
           · 파생 컬럼 → AcntVO 표시용 필드
             - USER_NM
               · ROLE_STUDENT → S.STDNT_NM
               · ROLE_PROF    → T.SKLSTF_NM
               · ROLE_ADMIN   → '관리자'
             - USER_STTUS_NM
               · ROLE_STUDENT → S.SKNRGS_STTUS 가 '재학'이면 '등록생' else 원본 값
               · ROLE_PROF    → '재직'
             - USER_SUBJCT_NM
               · ROLE_STUDENT → SJ_S.SUBJCT_NM (학생 소속 학과)
               · ROLE_PROF    → SJ_P.SUBJCT_NM (담당 학과)
             - USER_NO
               · ROLE_STUDENT → S.STDNT_NO (학번)
               · ROLE_PROF    → T.SKLSTF_ID (교번)
<<<<<<< Updated upstream
           · B.* 컬럼 → AuthorVO 로 변환 후 AcntVO.authorList 에 push

         - 출력 : AcntVO 1개
                  (authorList + USER_* 파생 필드 포함)
=======
           · B.* 컬럼 → AuthorVO 로 변환 후 AcntVO.authorVOList 에 push

         - 출력 : AcntVO 1개
                  (authorVOList + USER_* 파생 필드 포함)
>>>>>>> Stashed changes

      3) 계약
         - AcntVO 필드명
           acntId, fileGroupNo, password, acntTy,
           user_nm, userSttusNm, userSubjctNm, userNo,
<<<<<<< Updated upstream
           authorList
           이 정확히 존재해야 함
         - AuthorVO 필드명
           authorId, alwncDe, authorNm, authorDc, acntId
         - authorList 타입은 List<AuthorVO> 여야 함
=======
           authorVOList
           이 정확히 존재해야 함
         - AuthorVO 필드명
           authorId, alwncDe, authorNm, authorDc, acntId
         - authorVOList 타입은 List<AuthorVO> 여야 함
>>>>>>> Stashed changes
         - PK 역할 컬럼 ACNT_ID 는 <id> 로 명시되어 있음
           → MyBatis 는 이 키를 기준으로 동일 계정 row 를 병합하고
             AUTHOR 들을 리스트로 축적해야 함

      4) 보안 · 안전 전제
         - password 는 해시 문자열 전제 (평문이면 보안 파탄)
         - AcntVO 는 password + 실명(user_nm) + 학번/교번(userNo)을 함께 들고 있음
           · Controller 에서 그대로 JSON 응답으로 노출 금지
           · 외부 노출용 DTO 를 별도로 정의해야 안전
         - ROLE_* 값은 인가(authorization)에 직결되는 핵심 데이터
           → DB 가 단일 source of truth, 애플리케이션에서 변조 금지

      5) 유지보수자 가이드
         - B.ACNT_ID AS AUTHOR_ACNT_ID alias 는 AuthorVO.acntId 매핑에 필수
<<<<<<< Updated upstream
           → alias 제거/변경 시 authorList 매핑 깨짐
=======
           → alias 제거/변경 시 authorVOList 매핑 깨짐
>>>>>>> Stashed changes
         - USER_NM / USER_STTUS_NM / USER_SUBJCT_NM / USER_NO alias 는
           각각 AcntVO.user_nm / userSttusNm / userSubjctNm / userNo 에 매핑됨
           → SELECT 의 alias 와 resultMap 의 column 이름이 반드시 일치해야 함
         - STDNT / SKLSTF / PROFSR / SUBJCT 조인 조건, ROLE_* 문자열 변경 시
           · SELECT, VO, 인가 로직을 동시에 수정해야 정합성 유지
	  -->
	  <resultMap id="acntMap" type="kr.ac.collage_api.vo.AcntVO">
	    <!-- ACNT 본체 필드 -->
	    <id     property="acntId"        column="ACNT_ID"/>
	    <result property="fileGroupNo"   column="FILE_GROUP_NO"/>
	    <result property="password"      column="PASSWORD"/>
	    <result property="acntTy"        column="ACNT_TY"/>
	
	    <!-- 파생 표시용 필드 -->
	    <result property="user_nm"       column="USER_NM"/>
	    <result property="userSttusNm"   column="USER_STTUS_NM"/>
	    <result property="userSubjctNm"  column="USER_SUBJCT_NM"/>
	    <result property="userNo"        column="USER_NO"/>
	
	    <!-- AUTHOR 다건 컬렉션 -->
<<<<<<< Updated upstream
	    <collection property="authorList" resultMap="authorMap"/>
=======
	    <collection property="authorVOList" resultMap="authorMap"/>
>>>>>>> Stashed changes
	  </resultMap>
	
	  <!--
      블록: authorMap (권한 레코드 매핑)

      1) 코드 의도
         - AUTHOR (권한 테이블) 한 줄을 AuthorVO 로 변환
         - DitAccountMapper.findById 의 JOIN 결과에서 B.* 컬럼 alias를 사용

      2) 데이터 흐름
         - 입력 : AUTHOR B 관련 컬럼들
         - 출력 : AuthorVO (authorId, alwncDe, authorNm, authorDc, acntId)

      3) 계약
         - AuthorVO.authorId  ← AUTHOR_ID
         - AuthorVO.acntId    ← AUTHOR_ACNT_ID
           (B.ACNT_ID AS AUTHOR_ACNT_ID alias 기반)
         - alwncDe 는 권한 부여일자, DB 타입과 VO 타입 호환 필수

      4) 보안 · 안전 전제
         - ROLE_* 값은 인가 로직에 직접 사용됨
           → 이 값 기준으로 접근 제어를 걸기 때문에, 조작·오염되면 권한 우회 가능
         - 문자열 자체는 개인정보 직접 식별자는 아니지만,
           "ROLE_ADMIN" 등 내부 권한 명칭 외부 노출 가능 여부는 정책으로 판단

      5) 유지보수자 가이드
         - AUTHOR_ACNT_ID alias 는 필수
           → 변경 시 AuthorVO.acntId 에 값이 안 들어감
         - ALWNC_DE 타입(Date/Timestamp 등)에 맞춰
           VO 필드 타입(java.util.Date, LocalDateTime 등) 을 맞춰야 함
	  -->
	  <resultMap id="authorMap" type="kr.ac.collage_api.vo.AuthorVO">
	    <id     property="authorId" column="AUTHOR_ID"/>
	    <result property="alwncDe"  column="ALWNC_DE"/>
	    <result property="authorNm" column="AUTHOR_NM"/>
	    <result property="authorDc" column="AUTHOR_DC"/>
	    <result property="acntId"   column="AUTHOR_ACNT_ID"/>
	  </resultMap>
	
	  <!--
      블록: findById

      1) 코드 의도
         - 로그인 시 아이디(acntId)로
           계정 정보 + 권한 목록 + 헤더용 표시 정보(USER_*) 를 한 번에 조회
         - UserDetailsServiceImpl.loadUserByUsername(acntId) 에서 호출된다는 전제

      2) 데이터 흐름
         - 입력
           - #{acntId} : ACNT.ACNT_ID (로그인 아이디)
         - 가공
           - ACNT A    : 기본 계정 정보
           - AUTHOR B  : 계정이 가진 권한 목록
           - STDNT S   : ROLE_STUDENT 일 때 학생 기본 정보/학번/학과
           - SUBJCT SJ_S: 학생 소속 학과명
           - SKLSTF T  : ROLE_PROF 일 때 교직원 기본 정보(교번, 이름)
           - PROFSR PR : 교직원 담당 학과 코드
           - SUBJCT SJ_P: 교수 소속 학과명
           - CASE 로 파생 컬럼 생성
             · USER_NM
               - STUDENT → S.STDNT_NM
               - PROF    → T.SKLSTF_NM
               - ADMIN   → '관리자'
             · USER_STTUS_NM
               - STUDENT → S.SKNRGS_STTUS = '재학' 이면 '등록생' else 원본
               - PROF    → '재직'
             · USER_SUBJCT_NM
               - STUDENT → SJ_S.SUBJCT_NM
               - PROF    → SJ_P.SUBJCT_NM
             · USER_NO
               - STUDENT → S.STDNT_NO
               - PROF    → T.SKLSTF_ID
         - 출력
           - resultMap="acntMap"
<<<<<<< Updated upstream
           - AcntVO 1개 (authorList + USER_* 파생 필드 포함)
=======
           - AcntVO 1개 (authorVOList + USER_* 파생 필드 포함)
>>>>>>> Stashed changes

      3) 계약
         - #{acntId} NOT NULL, ACNT.ACNT_ID 와 1:1로 매칭된다는 전제
         - A.PASSWORD 는 해시 문자열이어야 함
         - AUTHOR 가 여러 줄이면
           · 동일 ACNT_ID 기준으로 AcntVO 에 병합되고
<<<<<<< Updated upstream
             authorList 에 누적되어야 함 (resultMap/collection 설정 필수)
=======
             authorVOList 에 누적되어야 함 (resultMap/collection 설정 필수)
>>>>>>> Stashed changes
         - USER_* 컬럼은 화면 전용 파생값
           · 원본 테이블 구조 변경 시 함께 검토 필요

      4) 보안 · 안전 전제
         - password + USER_* 값(실명, 학번/교번 등)이 함께 반환되므로
           → 이 VO 를 외부 API 응답으로 직접 반환하는 것은 금지
         - 실명/학번/교번은 로그에 과도하게 남기지 말 것

      5) 유지보수자 가이드
         - ROLE_* 문자열이 변경되면
           CASE, JOIN 조건, 인가 코드 전반을 같이 수정해야 함
         - STDNT / SKLSTF / PROFSR / SUBJCT 테이블 구조 변경 시
           JOIN, resultMap, VO 를 동시에 점검할 것
	  -->
	  <select id="findById" parameterType="string" resultMap="acntMap">
	    SELECT
	        A.ACNT_ID,
	        A.FILE_GROUP_NO,
	        A.PASSWORD,
	        A.ACNT_TY,
	
	        B.ALWNC_DE,
	        B.AUTHOR_ID,
	        B.AUTHOR_NM,
	        B.AUTHOR_DC,
	        B.ACNT_ID AS AUTHOR_ACNT_ID,
	
	        /* 상단 인사에 쓸 표시용 이름 */
	        CASE
	            WHEN B.AUTHOR_NM = 'ROLE_STUDENT' THEN S.STDNT_NM
	            WHEN B.AUTHOR_NM = 'ROLE_PROF'    THEN T.SKLSTF_NM
	            WHEN B.AUTHOR_NM = 'ROLE_ADMIN'   THEN '관리자'
	            ELSE NULL
	        END AS USER_NM,
	
	        /* 학적/재직 상태 표시용 */
	        CASE
	            WHEN B.AUTHOR_NM = 'ROLE_STUDENT' THEN
	                CASE
	                    WHEN S.SKNRGS_STTUS = '재학' THEN '등록생'
	                    ELSE S.SKNRGS_STTUS
	                END
	            WHEN B.AUTHOR_NM = 'ROLE_PROF' THEN '재직'
	            ELSE NULL
	        END AS USER_STTUS_NM,
	
	        /* 소속 학과명 (학생/교수 공통) */
	        CASE
	            WHEN B.AUTHOR_NM = 'ROLE_STUDENT' THEN SJ_S.SUBJCT_NM
	            WHEN B.AUTHOR_NM = 'ROLE_PROF'    THEN SJ_P.SUBJCT_NM
	            ELSE NULL
	        END AS USER_SUBJCT_NM,
	
	        /* 학번 / 교번 (헤더에서 복사 버튼에 쓸 값) */
	        CASE
	            WHEN B.AUTHOR_NM = 'ROLE_STUDENT' THEN S.STDNT_NO
	            WHEN B.AUTHOR_NM = 'ROLE_PROF'    THEN T.SKLSTF_ID
	            ELSE NULL
	        END AS USER_NO
	
	    FROM ACNT A
	    LEFT JOIN AUTHOR B
	        ON B.ACNT_ID = A.ACNT_ID
	
	    /* 학생 계정 전용 조인 */
	    LEFT JOIN STDNT S
	        ON S.ACNT_ID = A.ACNT_ID
	       AND B.AUTHOR_NM = 'ROLE_STUDENT'
	    LEFT JOIN SUBJCT SJ_S
	        ON SJ_S.SUBJCT_CODE = S.SUBJCT_CODE
	
	    /* 교수(교직원) 계정 전용 조인: ACNT → SKLSTF → PROFSR → SUBJCT */
	    LEFT JOIN SKLSTF T
	        ON T.ACNT_ID = A.ACNT_ID
	       AND B.AUTHOR_NM = 'ROLE_PROF'
	    LEFT JOIN PROFSR PR
	        ON PR.SKLSTF_ID = T.SKLSTF_ID
	    LEFT JOIN SUBJCT SJ_P
	        ON SJ_P.SUBJCT_CODE = PR.SUBJCT_CODE
	
	    WHERE A.ACNT_ID = #{acntId}
	  </select>


    <!--
      [1] 계정 ID로 권한 목록 조회

      입력
        - acntId : ACNT.ACNT_ID

      출력
        - AUTHOR.AUTHOR_ID 리스트
        - 예: ROLE_STUDENT, ROLE_PROF, ROLE_ADMIN 등

      계약
        - resultType="string" → List<String> 로 매핑
    -->
    <select id="findAuthoritiesByAcntId"
            parameterType="string"
            resultType="string">
        SELECT
            AUTHOR_NM
        FROM
            AUTHOR
        WHERE
            ACNT_ID = #{acntId}
        ORDER BY
            AUTHOR_NM
    </select>

    <!--
      [2] 계정 ID로 학생 학번 조회

      입력
        - acntId : ACNT.ACNT_ID

      출력
        - STDNT.STDNT_NO (단일값)
        - 해당 계정이 학생일 때만 존재한다고 가정.

      계약
        - resultType="string"
        - 일치 레코드가 없으면 null 반환 → ROLE_STUDENT 여부 판단에 사용
    -->
    <select id="findStdntNoByAcntId"
            parameterType="string"
            resultType="string">
        SELECT
            STDNT_NO
        FROM
            STDNT
        WHERE
            ACNT_ID = #{acntId}
    </select>
    
     <!-- ACNT_ID로 교수번호 조회 -->
	<select id="findProfsrNoByAcntId" parameterType="string" resultType="string">
	    SELECT p.PROFSR_NO
	    FROM PROFSR p
	         JOIN SKLSTF s ON s.SKLSTF_ID = p.SKLSTF_ID
	    WHERE s.ACNT_ID = #{acntId}
	</select>
	
     <!-- 계정 복구 관련 -->     
     <!-- 계정 복구: 학생 + 교직원 성명/생년월 통합으로 (로그인 아이디)ACNT_ID 조회 -->
     <select id="findByNameAndBirth"
		        parameterType="map"
		        resultType="string">
		  SELECT t.ACNT_ID
		  FROM (
		      -- 교직원 쪽
		      SELECT s."ACNT_ID"   AS ACNT_ID,
		             s."SKLSTF_NM" AS NAME,
		             s."BRTHDY"    AS BRTHDY
		      FROM   "SKLSTF" s
		
		      UNION ALL
		
		      -- 학생 쪽
		      SELECT st."ACNT_ID"  AS ACNT_ID,
		             st."STDNT_NM" AS NAME,
		             st."BRTHDY"   AS BRTHDY
		      FROM   "STDNT" st
		  ) t
		  WHERE t.NAME   = #{name}
		    AND t.BRTHDY = #{birth}
     </select>

		
	<!-- 계정 복구: 교직원(=교수)/학생 아이디 + 이메일 일치 여부 확인 -->
	<select id="existsByAcntIdAndEmail"
		        parameterType="map"
		        resultType="int">
		  SELECT COUNT(1)
		  FROM (
		    -- 학생: ACNT 테이블 이메일
		    SELECT
		           a.ACNT_ID AS ACNT_ID,
		           a.EMAIL   AS EMAIL
		    FROM   ACNT a
		
		    UNION ALL
		
		    -- 교수: SKLSTF.ACNT_ID + PROFSR.EMAIL_ADRES
		    SELECT
		           s.ACNT_ID     AS ACNT_ID,
		           p.EMAIL_ADRES AS EMAIL
		    FROM   PROFSR p
		    JOIN   SKLSTF s
		      ON   p.SKLSTF_ID = s.ACNT_ID   
		      	-- PROFSR.SKLSTF_ID == SKLSTF.ACNT_ID 전재
		  	) x
		  WHERE x.ACNT_ID = #{acntId}
		    AND x.EMAIL   = #{email}
	</select>
	
	<!-- 계정 복구 : ACNT 테이블 내 PASSWORD 칼럼 update -->
	<update id="updatePasswordByAcntIdAndEmail"
	        parameterType="map">
	  UPDATE ACNT
	  SET    "PASSWORD" = #{encoded}
	  WHERE  "ACNT_ID"  = #{acntId}
	  AND    "EMAIL"    = #{email}
	</update>
  
  <!--
      블록: selectStdntNoByAcntId

      1) 코드 의도
         - 현재 로그인된 계정 ID(acntId)로 학생 학번(STDNT_NO)을 얻는다
         - 증명서 발급 등 학생 전용 API에서 "지금 로그인한 사용자가 누구 학생인가"를 연결하는 핵심 키

      2) 데이터 흐름
         - 입력 : #{acntId}
         - 가공 : STDNT 테이블에서 ACNT_ID 로 역조회
         - 출력 : resultType="string"
                  즉 학번 STDNT_NO

      3) 계약
         - STDNT 테이블에 ACNT_ID FK 가 실제로 있어야 한다
           이 FK가 없거나 컬럼명이 다르면 동작 불능
         - 하나의 acntId 가 여러 STDNT_NO 에 매핑되는 상황은 없어야 한다
           그렇지 않으면 다중행 반환으로 MyBatis 예외 발생

      4) 보안 · 안전 전제
         - 이 쿼리는 "너의 acntId 로 학번을 알려줘" 구조라서
           현재 로그인 사용자의 학번 식별자(Personal Identifier)를 꺼낸다
         - 외부 사용자에게 노출되면 신원 유추가 가능하므로
           반드시 본인 세션 컨텍스트 안에서만 호출해야 안전

      5) 유지보수자 가이드
         - 인증방식이 교수/관리자 계정 등 비학생 계정으로 확장되면
           STDNT 에 없는 계정에 대해 NULL 리턴될 수 있다
           서비스단에서 NULL 처리 분기(학생 전용 기능 제한)가 필수다
  -->
  <select id="selectStdntNoByAcntId" parameterType="string" resultType="string">
    SELECT S.STDNT_NO
    FROM STDNT S
    WHERE S.ACNT_ID = #{acntId}
  </select>

  <!--
      블록: userSave

      1) 코드 의도
         - 신규 계정(ACNT) INSERT
         - 회원가입, PL이 수동 등록, 관리자 계정 생성 등에서 사용

      2) 데이터 흐름
         - 입력 : AcntVO
                  acntId, password(이미 해시된 값), fileGroupNo, acntTy
         - 가공 : INSERT INTO ACNT (...)
         - 출력 : DB에 1행 생성

      3) 계약
         - #{password} 는 반드시 사전에 해시 완료된 문자열이어야 한다
           평문 저장 금지
         - fileGroupNo 는 프로필 이미지 등 첨부파일 그룹 FK일 가능성
           jdbcType=NUMERIC 로 바인딩 중
           오라클 NUMBER와 타입 호환돼야 함
         - acntTy 는 역할 코드(S=학생 등). 이 값으로 기본 권한/화면 분기될 수 있음

      4) 보안 · 안전 전제
         - 비밀번호 해시 강도(BCrypt cost, Argon2 params 등)는 서비스단에서 강제해야 한다
         - DB권한이 있는 내부자가 ACNT 테이블을 직접 조회하면 해시값이 노출된다
           해시 재사용 공격 가능성이 있으므로 해시 알고리즘은 느리고 안전해야 한다

      5) 유지보수자 가이드
         - NOT NULL/UNIQUE 제약(ACNT_ID UNIQUE 등)과 동기화돼야 한다
           중복 ID 생성 시 여기서 예외를 바로 관측할 수 있어야 함
         - fileGroupNo 가 NULL 가능인지 여부는 스키마 확인 필요
           NULL 불허인데 파라미터가 안 오면 INSERT 실패
  -->
  <insert id="userSave" parameterType="kr.ac.collage_api.vo.AcntVO">
    INSERT INTO ACNT (
        ACNT_ID,
        PASSWORD,
        FILE_GROUP_NO,
        ACNT_TY
    )
    VALUES (
        #{acntId},
        #{password},
        #{fileGroupNo,jdbcType=NUMERIC},
        #{acntTy}
    )
  </insert>

  <!--
      블록: userSaveAuth

      1) 코드 의도
         - 신규 계정에 최소 1개의 권한을 부여한다
         - 기본값은 ROLE_STUDENT / '학생'
         - AUTHOR 테이블에 한 줄 INSERT

      2) 데이터 흐름
         - 입력 : AcntVO.acntId
         - 가공 : AUTHOR_SEQ.NEXTVAL 로 AUTHOR_ID 생성
                  ALWNC_DE 는 SYSDATE 로 생성 시각 기록
         - 출력 : AUTHOR 테이블에 권한 행 생성

      3) 계약
         - AUTHOR_SEQ 시퀀스가 존재해야 한다
           이름 바꾸면 바로 깨짐
         - ROLE_STUDENT 은 권한명(authorNm) 하드코드
           역할 체계 확장(교수, 관리자 등) 시 이 INSERT 구문 자체를 분기 또는 별 메서드로 분리해야 한다
         - AUTHOR_DC '학생' 은 사람이 읽는 설명. 다국어 요구 시 하드코드 문제 발생 가능

      4) 보안 · 안전 전제
         - 권한은 인가 결정의 기준이다
           잘못된 ROLE_* 를 부여하면 권한 상승 발생
         - 일반 사용자가 이 매퍼를 직접 호출할 수 있으면 안 된다
           회원가입 과정에서만 내부적으로 호출돼야 한다

      5) 유지보수자 가이드
         - ALWNC_DE 는 권한 부여일. DATE vs TIMESTAMP 여부에 따라 VO/매핑 타입 확인 필요
         - 추후 ROLE_STUDENT 외 ROLE_ADMIN 등 복수권한을 자동 부여하려면
           별도의 메서드를 만들고 여기(userSaveAuth)는 학생 전용으로 유지하는 편이 안전하다
  -->
	<insert id="userSaveAuth" parameterType="kr.ac.collage_api.vo.AcntVO">
	  /* 목적: AUTHOR PK는 상수가 아니라 시퀀스로 자동 발급 */
	  INSERT INTO AUTHOR (
	      AUTHOR_ID,     -- PK, 시퀀스 사용
	      ACNT_ID,       -- 계정 ID
	      AUTHOR_NM,     -- 권한명(예: ROLE_STUDENT / ROLE_ADMIN)
	      ALWNC_DE       -- 부여일자
	  ) VALUES (
	      AUTHOR_SEQ.NEXTVAL,  -- 수정: '20' 상수 → 시퀀스 호출
	      #{acntId},           -- 바인딩 변수
	      #{authorNm},         -- 바인딩 변수
	      SYSDATE              -- 발급 시각
	  )
	</insert>
	
	
	
</mapper>
