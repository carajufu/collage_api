<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="kr.ac.collage_api.mapper.DitAccountMapper">

  <!--
      블록: acntMap (계정 + 권한 목록 바인딩)

      1) 코드 의도
         - ACNT(계정 정보) 한 건과 AUTHOR(권한 목록) 다건을
           AcntVO.authorList(List<AuthorVO>) 형태로 한 번에 적재
         - 로그인 이후 세션/토큰 구성에 필요한 권한까지 로드

      2) 데이터 흐름
         - 입력 : findById SELECT 결과 (ACNT A LEFT JOIN AUTHOR B)
         - 가공 : 각 row의 A.* 는 AcntVO 필드에
                  B.* 는 AuthorVO 로 변환 후 AcntVO.authorList 에 push
         - 출력 : AcntVO 1개
                  (authorList 내부에 ROLE_* 권한들이 존재)

      3) 계약
         - AcntVO 필드명
           acntId, fileGroupNo, password, acntTy, authorList
           이 정확히 있어야 함
         - AuthorVO 필드명
           authorId, alwncDe, authorNm, authorDc, acntId
           이 있어야 함
         - authorList 는 반드시 List<AuthorVO> 여야 함
         - PK 역할 컬럼 ACNT_ID 는 <id> 로 명시되어 있음
           MyBatis는 이 키를 기준으로 동일 계정 row를 병합하고
           권한만 리스트로 축적함

      4) 보안 · 안전 전제
         - password 가 같이 로드됨
           password 필드는 해시 문자열이어야 하며 원문 비번 아님이 전제
         - password 는 외부 응답(JSON 등)으로 노출 금지
           즉 Controller에서 그대로 리턴하면 보안 위반
         - authorList 에 포함된 ROLE_* 정보는 인가 판단에 사용되므로
           위변조되면 안 됨
           DB가 단일 소스 오브 트루스

      5) 유지보수자 가이드
         - AUTHOR 쪽에서 B.ACNT_ID 를 AUTHOR_ACNT_ID 로 alias 한 이유:
           충돌 없이 AuthorVO.acntId 에 주입하기 위함
           이 alias 삭제하면 매핑 깨짐
         - fileGroupNo 는 프로필 이미지 등 파일그룹 FK일 가능성
           NUMBER 계열이면 AcntVO.fileGroupNo 타입도 Long/BigDecimal 등 숫자형이어야 함
         - ACNT_TY 는 'S'(학생) 'P'(교수) 등 역할 코드일 가능성
           하드코딩 enum처럼 쓰일 수 있으므로 바꾸기 전에 전체 영향 확인 필요
  -->
  <resultMap id="acntMap" type="kr.ac.collage_api.vo.AcntVO">
    <!-- ACNT 본체 필드 -->
    <id     property="acntId"      column="ACNT_ID"/>
    <result property="fileGroupNo" column="FILE_GROUP_NO"/>
    <result property="password"    column="PASSWORD"/>
    <result property="acntTy"      column="ACNT_TY"/>

    <!-- AUTHOR 다건 컬렉션 -->
    <collection property="authorList" resultMap="authorMap"/>
  </resultMap>

  <!--
      블록: authorMap (권한 레코드 매핑)

      1) 코드 의도
         - AUTHOR (권한 테이블) 한 줄을 AuthorVO 로 변환
         - DitAccountMapper.findById 의 JOIN 결과에서 B.* 컬럼 alias를 사용한다

      2) 데이터 흐름
         - 입력 : AUTHOR B 컬럼들
         - 출력 : AuthorVO

      3) 계약
         - AuthorVO.authorId 는 AUTHOR_ID 와 매핑
         - AuthorVO.acntId 는 AUTHOR_ACNT_ID 와 매핑
           (B.ACNT_ID AS AUTHOR_ACNT_ID 로 내려온 alias)
         - alwncDe 는 권한 부여일자. DATE/TIMESTAMP -> java 필드 타입 호환 필요

      4) 보안 · 안전 전제
         - ROLE_STUDENT 등 ROLE_* 값은 인가 핵심
           애플리케이션에서 이 값으로 접근 제어를 걸기 때문에
           조작되면 권한 우회 가능해짐
         - 외부에 그대로 노출하더라도 개인정보 직접 식별자는 아님
           단, "ROLE_ADMIN" 등 시스템 내부 권한명이 외부에 노출되는 게 정책상 허용인지는 별도 검토 필요

      5) 유지보수자 가이드
         - AUTHOR_ACNT_ID alias는 필수
           그대로 안 두면 AuthorVO.acntId 에 값이 안 박힘
         - ALWNC_DE(부여일) 타입 DATE/TIMESTAMP 여부에 따라
           VO에서 java.util.Date / LocalDateTime 등 맞춰야 함
  -->
  <resultMap id="authorMap" type="kr.ac.collage_api.vo.AuthorVO">
    <id     property="authorId" column="AUTHOR_ID"/>
    <result property="alwncDe"  column="ALWNC_DE"/>
    <result property="authorNm" column="AUTHOR_NM"/>
    <result property="authorDc" column="AUTHOR_DC"/>
    <result property="acntId"   column="AUTHOR_ACNT_ID"/>
  </resultMap>

  <!--
      블록: findById

      1) 코드 의도
         - 로그인 시 아이디로 계정 + 권한 목록 한 번에 조회
         - Spring Security UserDetailsServiceImpl.loadUserByUsername(acntId) 단계에서 호출된다는 전제

      2) 데이터 흐름
         - 입력 : #{acntId}
         - 가공 : ACNT A 기준으로
                  AUTHOR B 를 LEFT JOIN 해서 권한까지 끌어옴
                  권한이 없어도 계정은 나와야 하므로 LEFT JOIN
         - 출력 : resultMap="acntMap"
                  즉 AcntVO(authorList 포함)

      3) 계약
         - A.PASSWORD 는 이미 해시된 비밀번호여야 함
           Bcrypt/Argon2 등
           평문이면 보안 즉시 파탄
         - 동일 acntId 에 대해 AUTHOR 여러 줄이면
           MyBatis가 동일 ACNT_ID 를 가진 row들을 병합하고
           authorList 에 누적해야 함
           이게 안 되면 resultMap/collection 설정이 어긋난 것

      4) 보안 · 안전 전제
         - 반환 객체에는 password 가 포함됨
           이 VO를 그대로 세션 외부로 노출하거나 JSON 응답으로 내려가면 보안 위반
         - acntId 는 사용자 계정 ID (로그인 아이디) 이고
           STDNT_NO 같은 학번 등과는 다름
           학번 매핑은 별도 쿼리에서만 얻는다

      5) 유지보수자 가이드
         - ACNT와 AUTHOR 테이블명 변경 시 여기와 resultMap 둘 다 수정해야 함
         - AUTHOR 쪽 alias:
           B.ACNT_ID AS AUTHOR_ACNT_ID
           이 alias는 authorMap.acntId 매핑에 의존하므로 삭제 금지
  -->
  <select id="findById" parameterType="string" resultMap="acntMap">
    SELECT
      A.ACNT_ID,
      A.FILE_GROUP_NO,
      A.PASSWORD,
      A.ACNT_TY,
      B.ALWNC_DE,
      B.AUTHOR_ID,
      B.AUTHOR_NM,
      B.AUTHOR_DC,
      B.ACNT_ID AS AUTHOR_ACNT_ID
    FROM ACNT A
    LEFT JOIN AUTHOR B
      ON B.ACNT_ID = A.ACNT_ID
    WHERE A.ACNT_ID = #{acntId}
  </select>

    <!--
      [1] 계정 ID로 권한 목록 조회

      입력
        - acntId : ACNT.ACNT_ID

      출력
        - AUTHOR.AUTHOR_ID 리스트
        - 예: ROLE_STUDENT, ROLE_PROF, ROLE_ADMIN 등

      계약
        - resultType="string" → List<String> 로 매핑
    -->
    <select id="findAuthoritiesByAcntId"
            parameterType="string"
            resultType="string">
        SELECT
            AUTHOR_NM
        FROM
            AUTHOR
        WHERE
            ACNT_ID = #{acntId}
        ORDER BY
            AUTHOR_NM
    </select>

    <!--
      [2] 계정 ID로 학생 학번 조회

      입력
        - acntId : ACNT.ACNT_ID

      출력
        - STDNT.STDNT_NO (단일값)
        - 해당 계정이 학생일 때만 존재한다고 가정.

      계약
        - resultType="string"
        - 일치 레코드가 없으면 null 반환 → ROLE_STUDENT 여부 판단에 사용
    -->
    <select id="findStdntNoByAcntId"
            parameterType="string"
            resultType="string">
        SELECT
            STDNT_NO
        FROM
            STDNT
        WHERE
            ACNT_ID = #{acntId}
    </select>
    
     <!-- ACNT_ID로 교수번호 조회 -->
	<select id="findProfsrNoByAcntId" parameterType="string" resultType="string">
	    SELECT p.PROFSR_NO
	    FROM PROFSR p
	         JOIN SKLSTF s ON s.SKLSTF_ID = p.SKLSTF_ID
	    WHERE s.ACNT_ID = #{acntId}
	</select>
	
     <!-- 계정 복구 관련 -->     
     <!-- 계정 복구: 학생 + 교직원 성명/생년월 통합으로 (로그인 아이디)ACNT_ID 조회 -->
     <select id="findByNameAndBirth"
		        parameterType="map"
		        resultType="string">
		  SELECT t.ACNT_ID
		  FROM (
		      -- 교직원 쪽
		      SELECT s."ACNT_ID"   AS ACNT_ID,
		             s."SKLSTF_NM" AS NAME,
		             s."BRTHDY"    AS BRTHDY
		      FROM   "SKLSTF" s
		
		      UNION ALL
		
		      -- 학생 쪽
		      SELECT st."ACNT_ID"  AS ACNT_ID,
		             st."STDNT_NM" AS NAME,
		             st."BRTHDY"   AS BRTHDY
		      FROM   "STDNT" st
		  ) t
		  WHERE t.NAME   = #{name}
		    AND t.BRTHDY = #{birth}
     </select>

		
	<!-- 계정 복구: 교직원(=교수)/학생 아이디 + 이메일 일치 여부 확인 -->
	<select id="existsByAcntIdAndEmail"
		        parameterType="map"
		        resultType="int">
		  SELECT COUNT(1)
		  FROM (
		    -- 학생: ACNT 테이블 이메일
		    SELECT
		           a.ACNT_ID AS ACNT_ID,
		           a.EMAIL   AS EMAIL
		    FROM   ACNT a
		
		    UNION ALL
		
		    -- 교수: SKLSTF.ACNT_ID + PROFSR.EMAIL_ADRES
		    SELECT
		           s.ACNT_ID     AS ACNT_ID,
		           p.EMAIL_ADRES AS EMAIL
		    FROM   PROFSR p
		    JOIN   SKLSTF s
		      ON   p.SKLSTF_ID = s.ACNT_ID   
		      	-- PROFSR.SKLSTF_ID == SKLSTF.ACNT_ID 전재
		  	) x
		  WHERE x.ACNT_ID = #{acntId}
		    AND x.EMAIL   = #{email}
	</select>
	
	<!-- 계정 복구 : ACNT 테이블 내 PASSWORD 칼럼 update -->
	<update id="updatePasswordByAcntIdAndEmail"
	        parameterType="map">
	  UPDATE ACNT
	  SET    "PASSWORD" = #{encoded}
	  WHERE  "ACNT_ID"  = #{acntId}
	  AND    "EMAIL"    = #{email}
	</update>
  
  <!--
      블록: selectStdntNoByAcntId

      1) 코드 의도
         - 현재 로그인된 계정 ID(acntId)로 학생 학번(STDNT_NO)을 얻는다
         - 증명서 발급 등 학생 전용 API에서 "지금 로그인한 사용자가 누구 학생인가"를 연결하는 핵심 키

      2) 데이터 흐름
         - 입력 : #{acntId}
         - 가공 : STDNT 테이블에서 ACNT_ID 로 역조회
         - 출력 : resultType="string"
                  즉 학번 STDNT_NO

      3) 계약
         - STDNT 테이블에 ACNT_ID FK 가 실제로 있어야 한다
           이 FK가 없거나 컬럼명이 다르면 동작 불능
         - 하나의 acntId 가 여러 STDNT_NO 에 매핑되는 상황은 없어야 한다
           그렇지 않으면 다중행 반환으로 MyBatis 예외 발생

      4) 보안 · 안전 전제
         - 이 쿼리는 "너의 acntId 로 학번을 알려줘" 구조라서
           현재 로그인 사용자의 학번 식별자(Personal Identifier)를 꺼낸다
         - 외부 사용자에게 노출되면 신원 유추가 가능하므로
           반드시 본인 세션 컨텍스트 안에서만 호출해야 안전

      5) 유지보수자 가이드
         - 인증방식이 교수/관리자 계정 등 비학생 계정으로 확장되면
           STDNT 에 없는 계정에 대해 NULL 리턴될 수 있다
           서비스단에서 NULL 처리 분기(학생 전용 기능 제한)가 필수다
  -->
  <select id="selectStdntNoByAcntId" parameterType="string" resultType="string">
    SELECT S.STDNT_NO
    FROM STDNT S
    WHERE S.ACNT_ID = #{acntId}
  </select>

  <!--
      블록: userSave

      1) 코드 의도
         - 신규 계정(ACNT) INSERT
         - 회원가입, PL이 수동 등록, 관리자 계정 생성 등에서 사용

      2) 데이터 흐름
         - 입력 : AcntVO
                  acntId, password(이미 해시된 값), fileGroupNo, acntTy
         - 가공 : INSERT INTO ACNT (...)
         - 출력 : DB에 1행 생성

      3) 계약
         - #{password} 는 반드시 사전에 해시 완료된 문자열이어야 한다
           평문 저장 금지
         - fileGroupNo 는 프로필 이미지 등 첨부파일 그룹 FK일 가능성
           jdbcType=NUMERIC 로 바인딩 중
           오라클 NUMBER와 타입 호환돼야 함
         - acntTy 는 역할 코드(S=학생 등). 이 값으로 기본 권한/화면 분기될 수 있음

      4) 보안 · 안전 전제
         - 비밀번호 해시 강도(BCrypt cost, Argon2 params 등)는 서비스단에서 강제해야 한다
         - DB권한이 있는 내부자가 ACNT 테이블을 직접 조회하면 해시값이 노출된다
           해시 재사용 공격 가능성이 있으므로 해시 알고리즘은 느리고 안전해야 한다

      5) 유지보수자 가이드
         - NOT NULL/UNIQUE 제약(ACNT_ID UNIQUE 등)과 동기화돼야 한다
           중복 ID 생성 시 여기서 예외를 바로 관측할 수 있어야 함
         - fileGroupNo 가 NULL 가능인지 여부는 스키마 확인 필요
           NULL 불허인데 파라미터가 안 오면 INSERT 실패
  -->
  <insert id="userSave" parameterType="kr.ac.collage_api.vo.AcntVO">
    INSERT INTO ACNT (
        ACNT_ID,
        PASSWORD,
        FILE_GROUP_NO,
        ACNT_TY
    )
    VALUES (
        #{acntId},
        #{password},
        #{fileGroupNo,jdbcType=NUMERIC},
        #{acntTy}
    )
  </insert>

  <!--
      블록: userSaveAuth

      1) 코드 의도
         - 신규 계정에 최소 1개의 권한을 부여한다
         - 기본값은 ROLE_STUDENT / '학생'
         - AUTHOR 테이블에 한 줄 INSERT

      2) 데이터 흐름
         - 입력 : AcntVO.acntId
         - 가공 : AUTHOR_SEQ.NEXTVAL 로 AUTHOR_ID 생성
                  ALWNC_DE 는 SYSDATE 로 생성 시각 기록
         - 출력 : AUTHOR 테이블에 권한 행 생성

      3) 계약
         - AUTHOR_SEQ 시퀀스가 존재해야 한다
           이름 바꾸면 바로 깨짐
         - ROLE_STUDENT 은 권한명(authorNm) 하드코드
           역할 체계 확장(교수, 관리자 등) 시 이 INSERT 구문 자체를 분기 또는 별 메서드로 분리해야 한다
         - AUTHOR_DC '학생' 은 사람이 읽는 설명. 다국어 요구 시 하드코드 문제 발생 가능

      4) 보안 · 안전 전제
         - 권한은 인가 결정의 기준이다
           잘못된 ROLE_* 를 부여하면 권한 상승 발생
         - 일반 사용자가 이 매퍼를 직접 호출할 수 있으면 안 된다
           회원가입 과정에서만 내부적으로 호출돼야 한다

      5) 유지보수자 가이드
         - ALWNC_DE 는 권한 부여일. DATE vs TIMESTAMP 여부에 따라 VO/매핑 타입 확인 필요
         - 추후 ROLE_STUDENT 외 ROLE_ADMIN 등 복수권한을 자동 부여하려면
           별도의 메서드를 만들고 여기(userSaveAuth)는 학생 전용으로 유지하는 편이 안전하다
  -->
	<insert id="userSaveAuth" parameterType="kr.ac.collage_api.vo.AcntVO">
	  /* 목적: AUTHOR PK는 상수가 아니라 시퀀스로 자동 발급 */
	  INSERT INTO AUTHOR (
	      AUTHOR_ID,     -- PK, 시퀀스 사용
	      ACNT_ID,       -- 계정 ID
	      AUTHOR_NM,     -- 권한명(예: ROLE_STUDENT / ROLE_ADMIN)
	      ALWNC_DE       -- 부여일자
	  ) VALUES (
	      AUTHOR_SEQ.NEXTVAL,  -- 수정: '20' 상수 → 시퀀스 호출
	      #{acntId},           -- 바인딩 변수
	      #{authorNm},         -- 바인딩 변수
	      SYSDATE              -- 발급 시각
	  )
	</insert>
	
	
	
</mapper>
